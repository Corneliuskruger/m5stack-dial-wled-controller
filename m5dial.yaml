output:
  - platform: ledc
    pin: GPIO9
    id: backlight_pwm
    frequency: 1000 Hz

esphome:
  name: m5stack-dial-wled-controller
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    priority: -100
    then:
      - output.turn_on: backlight_pwm
      - output.set_level:
          id: backlight_pwm
          level: 100%
      - lambda: |-
          // Initialize groups
          id(num_groups) = 2;
          id(group_names)[0] = "All Devices";
          id(group_names)[1] = "Custom 1";
          
          ESP_LOGD("groups", "Initialized groups: %s, %s", 
                   id(group_names)[0].c_str(), 
                   id(group_names)[1].c_str());
  on_loop:
    - lambda: |-
        static unsigned long last_print = 0;
        if (millis() - last_print > 5000) {
          ESP_LOGD("loop", "Loop running, free heap: %u", ESP.getFreeHeap());
          last_print = millis();
        }
    # Define colors
color:
  - id: COLOR_BLACK
    red: 0%
    green: 0%
    blue: 0%
  - id: COLOR_WHITE
    red: 100%
    green: 100%
    blue: 100%
  - id: COLOR_RED
    red: 100%
    green: 0%
    blue: 0%
  - id: COLOR_GREEN
    red: 0%
    green: 100%
    blue: 0%
  - id: COLOR_BLUE
    red: 0%
    green: 50%
    blue: 100%
  - id: COLOR_YELLOW
    red: 100%
    green: 100%
    blue: 0%
  - id: COLOR_CYAN
    red: 0%
    green: 100%
    blue: 100%
  - id: COLOR_MAGENTA
    red: 100%
    green: 0%
    blue: 100%
  - id: COLOR_ORANGE
    red: 100%
    green: 50%
    blue: 0%
  - id: COLOR_PURPLE
    red: 75%
    green: 0%
    blue: 100%
  - id: COLOR_GREY
    red: 50%
    green: 50%
    blue: 50%
  - id: COLOR_LIGHT_GREY
    red: 75%
    green: 75%
    blue: 75%
  - id: COLOR_DARK_GREY
    red: 25%
    green: 25%
    blue: 25%
    
esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

logger:
  level: DEBUG
  logs:
    component: ERROR
    display: DEBUG

api:
  encryption:
    key: !secret encryptionKey

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

i2c:
  id: i2c_bus
  sda: GPIO11
  scl: GPIO12
  scan: true

spi:
  clk_pin: GPIO6
  mosi_pin: GPIO5

font:
  - file: "fonts/Roboto-Regular.ttf"
    id: font_small
    size: 14
  - file: "fonts/Roboto-Bold.ttf"
    id: font_medium
    size: 18
  - file: "fonts/Roboto-Bold.ttf"
    id: font_large
    size: 24
    # Material Design Icons for menu
  - file: "https://github.com/Templarian/MaterialDesign-Webfont/raw/master/fonts/materialdesignicons-webfont.ttf"
    id: font_icons
    size: 28
    glyphs:
      - "\U000F0335"  # devices
      - "\U000F0425"  # power
      - "\U000F0E0C"  # colors
      - "\U000F0766"  # effects
      - "\U000F00DF"  # brightness
      - "\U000F1254"  # groups
      - "\U000F1C2B"  # presets
      - "\U000F0FE2"  # mode
      - "\U000F05E1"  # checked 
      - "\U000F0130"  # unchecked

# Sync WLED device list from Home Assistant
text_sensor:
  - platform: homeassistant
    id: wled_device_list
    entity_id: sensor.wled_device_list
    attribute: devices
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("wled_sync", "Received device list: %s", x.c_str());
            id(device_names).clear();
            id(device_entity_ids).clear();
            
            std::string current = "";
            std::string current_name = "";
            bool parsing_name = true;
            
            for (size_t i = 0; i < x.length(); i++) {
              char c = x[i];
              
              if (c == '|') {
                current_name = current;
                current = "";
                parsing_name = false;
              } else if (c == ',') {
                if (!current_name.empty() && !current.empty()) {
                  id(device_names).push_back(current_name);
                  id(device_entity_ids).push_back(current);
                  ESP_LOGD("parse", "Added device: %s (%s)", current_name.c_str(), current.c_str());
                }
                current_name = "";
                current = "";
                parsing_name = true;
              } else {
                current += c;
              }
            }
            
            if (!current_name.empty() && !current.empty()) {
              id(device_names).push_back(current_name);
              id(device_entity_ids).push_back(current);
              ESP_LOGD("parse", "Added device: %s (%s)", current_name.c_str(), current.c_str());
            }
            
            id(num_devices) = id(device_names).size();
            ESP_LOGD("parse", "Total devices: %d", id(num_devices));
            
            if (id(selected_device_index) >= id(num_devices)) {
              id(selected_device_index) = 0;
            }
  
  - platform: homeassistant
    id: wled_effects
    entity_id: sensor.wled_device_list
    attribute: effects
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("effects", "Parsing effects: %s", x.c_str());
            
            // Parse effects into a temporary list
            std::vector<std::string> effects;
            std::string current = "";
            
            for (char c : x) {
              if (c == ',') {
                if (!current.empty()) {
                  effects.push_back(current);
                  current = "";
                }
              } else {
                current += c;
              }
            }
            
            if (!current.empty()) {
              effects.push_back(current);
            }
            
            // Copy the same effect list to all devices
            for (int i = 0; i < 20; i++) {
              id(effect_lists)[i] = effects;
              id(effect_counts)[i] = effects.size();
            }
            
            ESP_LOGD("effects", "Loaded %d effects for all devices", effects.size());

# Track current state of devices
sensor:
  - platform: rotary_encoder
    name: "Dial Encoder"
    id: dial_encoder
    pin_a: GPIO40
    pin_b: GPIO41
    resolution: 1
    filters:
      - debounce: 0.1s
    on_clockwise:
      - lambda: |-
          if (id(current_menu) == 0) {
            id(menu_index) += 1;
            if (id(menu_index) > 7) id(menu_index) = 7;
          }
          else if (id(current_menu) == 1) {
            // Device selection - include "Done" option
            id(device_select_index) += 1;
            if (id(device_select_index) > id(num_devices)) id(device_select_index) = id(num_devices);  // +1 for Done button
          }
          else if (id(current_menu) == 2) {
            // Color wheel
            id(color_hue) += 3;
            if (id(color_hue) >= 360) id(color_hue) -= 360;
          }
          else if (id(current_menu) == 3) {
            // Effect selection
            id(menu_index) += 1;
            int max_effects = 0;
            if (id(control_mode) == 0 && id(selected_device_index) < id(num_devices)) {
              max_effects = id(effect_counts)[id(selected_device_index)];
            } else if (id(control_mode) == 1) {
              max_effects = id(effect_counts)[0];  // Use first device's effects
            }
            if (id(menu_index) >= max_effects) id(menu_index) = max_effects - 1;
          }
          else if (id(current_menu) == 4) {
            // Brightness
            id(brightness_value) += 5;
            if (id(brightness_value) > 255) id(brightness_value) = 255;
          }
          else if (id(current_menu) == 5) {
            // Group selection
            id(group_select_index) += 1;
            if (id(group_select_index) >= id(num_groups)) id(group_select_index) = id(num_groups) - 1;
          }
          else if (id(current_menu) == 7) {
            // Preset selection
            id(preset_select_index) += 1;
            if (id(preset_select_index) >= id(num_presets)) id(preset_select_index) = id(num_presets) - 1;
          }
          else if (id(current_menu) == 8) {
            // Save group prompt - 2 options
            id(menu_index) += 1;
            if (id(menu_index) > 1) id(menu_index) = 1;
          }
    on_anticlockwise:
      - lambda: |-
          if (id(current_menu) == 0) {
            id(menu_index) -= 1;
            if (id(menu_index) < 0) id(menu_index) = 0;
          }
          else if (id(current_menu) == 1) {
            id(device_select_index) -= 1;
            if (id(device_select_index) < 0) id(device_select_index) = 0;
          }
          else if (id(current_menu) == 2) {
            id(color_hue) -= 3;
            if (id(color_hue) < 0) id(color_hue) += 360;
          }
          else if (id(current_menu) == 3) {
            id(menu_index) -= 1;
            if (id(menu_index) < 0) id(menu_index) = 0;
          }
          else if (id(current_menu) == 4) {
            id(brightness_value) -= 5;
            if (id(brightness_value) < 0) id(brightness_value) = 0;
          }
          else if (id(current_menu) == 5) {
            id(group_select_index) -= 1;
            if (id(group_select_index) < 0) id(group_select_index) = 0;
          }
          else if (id(current_menu) == 7) {
            id(preset_select_index) -= 1;
            if (id(preset_select_index) < 0) id(preset_select_index) = 0;
          }
          else if (id(current_menu) == 8) {
            id(menu_index) -= 1;
            if (id(menu_index) < 0) id(menu_index) = 0;
          }

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO42
      inverted: true
      mode:
        input: true
        pullup: true
    name: "Dial Button"
    id: dial_button
    on_click:
      - min_length: 50ms
        max_length: 1000ms
        then:
          # Toggle Power - handle both single device and group
          - if:
              condition:
                lambda: 'return id(current_menu) == 0 && id(menu_index) == 1;'
              then:
                - script.execute: toggle_power_action
        
          # Set Color
          - if:
              condition:
                lambda: 'return id(current_menu) == 2;'
              then:
                # Single device
                - if:
                    condition:
                      lambda: 'return id(control_mode) == 0 && id(selected_device_index) < id(num_devices);'
                    then:
                      - homeassistant.service:
                          service: light.turn_on
                          data_template:
                            entity_id: !lambda 'return id(device_entity_ids)[id(selected_device_index)];'
                            hs_color: !lambda |-
                              char buf[32];
                              snprintf(buf, sizeof(buf), "[%d, 100]", id(color_hue));
                              return std::string(buf);
                # Group
                - if:
                    condition:
                      lambda: 'return id(control_mode) == 1;'
                    then:
                      - homeassistant.service:
                          service: light.turn_on
                          data_template:
                            entity_id: !lambda |-
                              std::string entities = "";
                              for (int i = 0; i < id(group_devices)[id(selected_group_index)].size(); i++) {
                                int dev_idx = id(group_devices)[id(selected_group_index)][i];
                                if (dev_idx < id(num_devices)) {
                                  if (i > 0) entities += ",";
                                  entities += id(device_entity_ids)[dev_idx];
                                }
                              }
                              return entities;
                            hs_color: !lambda |-
                              char buf[32];
                              snprintf(buf, sizeof(buf), "[%d, 100]", id(color_hue));
                              return std::string(buf);
          
          # Set Effect
          - if:
              condition:
                lambda: 'return id(current_menu) == 3 && id(menu_index) < id(effect_counts)[0];'
              then:
                # Single device
                - if:
                    condition:
                      lambda: 'return id(control_mode) == 0 && id(selected_device_index) < id(num_devices);'
                    then:
                      - homeassistant.service:
                          service: light.turn_on
                          data_template:
                            entity_id: !lambda 'return id(device_entity_ids)[id(selected_device_index)];'
                            effect: !lambda 'return id(effect_lists)[id(selected_device_index)][id(menu_index)];'
                # Group
                - if:
                    condition:
                      lambda: 'return id(control_mode) == 1;'
                    then:
                      - homeassistant.service:
                          service: light.turn_on
                          data_template:
                            entity_id: !lambda |-
                              std::string entities = "";
                              for (int i = 0; i < id(group_devices)[id(selected_group_index)].size(); i++) {
                                int dev_idx = id(group_devices)[id(selected_group_index)][i];
                                if (dev_idx < id(num_devices)) {
                                  if (i > 0) entities += ",";
                                  entities += id(device_entity_ids)[dev_idx];
                                }
                              }
                              return entities;
                            effect: !lambda 'return id(effect_lists)[0][id(menu_index)];'
          
          # Set Brightness
          - if:
              condition:
                lambda: 'return id(current_menu) == 4;'
              then:
                # Single device
                - if:
                    condition:
                      lambda: 'return id(control_mode) == 0 && id(selected_device_index) < id(num_devices);'
                    then:
                      - homeassistant.service:
                          service: light.turn_on
                          data_template:
                            entity_id: !lambda 'return id(device_entity_ids)[id(selected_device_index)];'
                            brightness: !lambda 'return to_string(id(brightness_value));'
                # Group
                - if:
                    condition:
                      lambda: 'return id(control_mode) == 1;'
                    then:
                      - homeassistant.service:
                          service: light.turn_on
                          data_template:
                            entity_id: !lambda |-
                              std::string entities = "";
                              for (int i = 0; i < id(group_devices)[id(selected_group_index)].size(); i++) {
                                int dev_idx = id(group_devices)[id(selected_group_index)][i];
                                if (dev_idx < id(num_devices)) {
                                  if (i > 0) entities += ",";
                                  entities += id(device_entity_ids)[dev_idx];
                                }
                              }
                              return entities;
                            brightness: !lambda 'return to_string(id(brightness_value));'
                            
          # THEN change menu state
          - lambda: |-
              ESP_LOGD("button", "Handler starting at %lu", millis());
              ESP_LOGD("button", "Menu: %d, Index: %d, Devices: %d", id(current_menu), id(menu_index), id(num_devices));
              
              if (id(current_menu) == 0) {
                // Main menu navigation - menu_index already set by rotary encoder
                if (id(menu_index) == 0 && id(num_devices) > 0) {
                  id(current_menu) = 1;
                  id(device_select_index) = id(selected_device_index);
                } else if (id(menu_index) == 2) {
                  id(current_menu) = 2;
                } else if (id(menu_index) == 3) {
                  id(current_menu) = 3;
                  id(menu_index) = 0;  // Effect list uses menu_index, so reset here
                } else if (id(menu_index) == 4) {
                  id(current_menu) = 4;
                } else if (id(menu_index) == 5) {
                  id(current_menu) = 5;
                  id(group_select_index) = id(selected_group_index);
                } else if (id(menu_index) == 6) {
                  id(current_menu) = 7;
                  id(preset_select_index) = 0;
                } else if (id(menu_index) == 7) {
                  id(control_mode) = (id(control_mode) == 0) ? 1 : 0;
                }
              }
              else if (id(current_menu) == 1) {
                // Device selection - save menu_index before returning
                int saved_menu_index = 0;  // "Select Device"
                
                if (id(device_select_index) == id(num_devices)) {
                  // Done button logic
                  if (id(selected_devices).size() == 0) {
                    id(current_menu) = 0;
                    id(menu_index) = saved_menu_index;  // Restore
                  } else if (id(selected_devices).size() == 1) {
                    id(selected_device_index) = id(selected_devices)[0];
                    id(control_mode) = 0;
                    id(selected_devices).clear();
                    id(current_menu) = 0;
                    id(menu_index) = saved_menu_index;  // Restore
                  } else {
                    id(current_menu) = 8;
                    id(menu_index) = 0;
                  }
                } else {
                  // Toggle device selection
                  int device_idx = id(device_select_index);
                  bool found = false;
                  for (int i = 0; i < id(selected_devices).size(); i++) {
                    if (id(selected_devices)[i] == device_idx) {
                      id(selected_devices).erase(id(selected_devices).begin() + i);
                      found = true;
                      break;
                    }
                  }
                  if (!found) {
                    id(selected_devices).push_back(device_idx);
                  }
                }
              }
              else if (id(current_menu) == 2) {
                // Color menu - return to "Change Color"
                id(current_menu) = 0;
                id(menu_index) = 2;  // Keep on "Change Color"
              }
              else if (id(current_menu) == 3) {
                // Effect menu - return to "Change Effect"
                id(current_menu) = 0;
                id(menu_index) = 3;  // Keep on "Change Effect"
              }
              else if (id(current_menu) == 4) {
                // Brightness menu - return to "Brightness"
                id(current_menu) = 0;
                id(menu_index) = 4;  // Keep on "Brightness"
              }
              else if (id(current_menu) == 5) {
                // Group selection
                id(selected_group_index) = id(group_select_index);
                if (id(group_select_index) == 0) {
                  id(current_menu) = 0;
                  id(menu_index) = 5;  // Keep on "Groups"
                } else {
                  id(current_menu) = 6;
                  id(menu_index) = 0;
                }
              }
              else if (id(current_menu) == 6) {
                // Group edit - toggle device
                // ... existing toggle code ...
              }
              else if (id(current_menu) == 7) {
                // Presets - return to "Presets"
                if (id(preset_select_index) < id(num_presets)) {
                  id(color_hue) = id(preset_hues)[id(preset_select_index)];
                  id(brightness_value) = id(preset_brightness)[id(preset_select_index)];
                }
                id(current_menu) = 0;
                id(menu_index) = 6;  // Keep on "Presets"
              }
              else if (id(current_menu) == 8) {
                // Save group prompt
                if (id(menu_index) == 0) {
                  id(control_mode) = 1;
                  id(group_devices)[1].clear();
                  for (int i = 0; i < id(selected_devices).size(); i++) {
                    id(group_devices)[1].push_back(id(selected_devices)[i]);
                  }
                  id(selected_group_index) = 1;
                  id(selected_devices).clear();
                } else if (id(menu_index) == 1) {
                  if (id(num_groups) < 10) {
                    id(group_devices)[id(num_groups)].clear();
                    for (int i = 0; i < id(selected_devices).size(); i++) {
                      id(group_devices)[id(num_groups)].push_back(id(selected_devices)[i]);
                    }
                    char name[32];
                    snprintf(name, sizeof(name), "Group %d", id(num_groups));
                    id(group_names)[id(num_groups)] = name;
                    id(selected_group_index) = id(num_groups);
                    id(num_groups)++;
                    id(control_mode) = 1;
                    id(selected_devices).clear();
                  }
                }
                id(current_menu) = 0;
                id(menu_index) = 0;  // Return to "Select Device"
              }

display:
  - platform: ili9xxx
    model: GC9A01A
    id: my_display
    cs_pin: GPIO7
    dc_pin: GPIO4
    reset_pin: GPIO8
    invert_colors: True
    rotation: 0
    update_interval: 250ms
    lambda: |-
      it.fill(id(COLOR_BLACK));
            
      int center_x = 120;
      int center_y = 120;
      
      // Show loading message if no devices synced yet
      if (id(num_devices) == 0) {
        it.printf(center_x, center_y - 20, id(font_medium), id(COLOR_YELLOW), TextAlign::CENTER, "Syncing WLED");
        it.printf(center_x, center_y + 20, id(font_small), id(COLOR_WHITE), TextAlign::CENTER, "devices from HA...");
        return;
      }
      
      // Display current device at top - MOVED DOWN from y=5 to y=20
      if (id(selected_device_index) < id(num_devices)) {
        it.printf(center_x, 20, id(font_small), id(COLOR_CYAN), TextAlign::CENTER, "%s", id(device_names)[id(selected_device_index)].c_str());
      }
      
      // Main Menu - Circular Icon Layout
      if (id(current_menu) == 0) {
        // Black background
        it.filled_rectangle(0, 0, 240, 240, id(COLOR_BLACK));
        
        // Menu configuration
        const char* menu_icons[] = {
                "\U000F0335",  // mdi-devices
                "\U000F0425",  // mdi-power
                "\U000F0E0C",  // mdi-palette
                "\U000F0766",  // mdi-star-box
                "\U000F00DF",  // mdi-brightness-6
                "\U000F1254",  // mdi-google-circles-communities
                "\U000F1C2B",  // mdi-bookmark-multiple
                "\U000F0FE2"  // mdi-swap-horizontal
        };
        
        Color menu_colors[] = {
          id(COLOR_CYAN),
          id(COLOR_RED),
          id(COLOR_MAGENTA),
          id(COLOR_YELLOW),
          id(COLOR_ORANGE),
          id(COLOR_GREEN),
          id(COLOR_BLUE),
          id(COLOR_PURPLE)
        };
        
        const char* menu_labels[] = {
          "Devices",
          "Power",
          "Color",
          "Effect",
          "Bright",
          "Groups",
          "Presets",
          "Mode"
        };
        
        int num_items = 8;
        int radius = 95;  // Distance from center
        int center_x = 120;
        int center_y = 120;
        
        // Calculate rotation offset so selected item is at 9 o'clock (270°)
        float selected_angle = 270.0;
        float angle_per_item = 360.0 / num_items;
        
        // Draw each menu item
        for (int i = 0; i < num_items; i++) {
          // Calculate angle for this item
          // Selected item should be at 270°, so offset by menu_index
          float angle = selected_angle + ((i - id(menu_index)) * angle_per_item);
          float angle_rad = angle * 3.14159 / 180.0;
          
          // Calculate position
          int x = center_x + radius * cos(angle_rad);
          int y = center_y + radius * sin(angle_rad);
          
          // Determine if this is the selected item
          bool is_selected = (i == id(menu_index));
          
          // Draw colored circle background
          int circle_radius = is_selected ? 22 : 18;
          it.filled_circle(x, y, circle_radius, menu_colors[i]);
          
          // Draw icon
          it.printf(x, y, id(font_icons), 
                   is_selected ? id(COLOR_BLACK) : id(COLOR_WHITE),
                   TextAlign::CENTER, menu_icons[i]);
          
          // Draw label for selected item
          if (is_selected) {
            it.printf(center_x, center_y + 40, id(font_medium), id(COLOR_WHITE), 
                     TextAlign::CENTER, "%s", menu_labels[i]);
          }
        }
        
        // Center info - device name or group name
        if (id(control_mode) == 0) {
          if (id(selected_device_index) < id(num_devices)) {
            it.printf(center_x, center_y - 10, id(font_small), id(COLOR_LIGHT_GREY), 
                     TextAlign::CENTER, "%s", id(device_names)[id(selected_device_index)].c_str());
          }
        } else {
          it.printf(center_x, center_y - 10, id(font_small), id(COLOR_GREEN), 
                   TextAlign::CENTER, "Group: %s", id(group_names)[id(selected_group_index)].c_str());
        }
        
        // Indicator dot at bottom
        it.filled_circle(center_x, 220, 3, id(COLOR_WHITE));
      }
      // Device Selection Menu - Contour List
      else if (id(current_menu) == 1) {
        // Black background
        it.fill(id(COLOR_BLACK));
        
        int center_x = 120;
        int center_y = 120;
        int active_y = 120;  // Active item always at 9 o'clock (vertical center)
        int item_spacing = 35;
        int total_items = id(num_devices) + 1;  // +1 for "Done"
        
        // Title at top
        it.printf(center_x, 15, id(font_medium), id(COLOR_WHITE), 
                 TextAlign::CENTER, "Select Devices");
        
        // Calculate visible range (items that fit on screen)
        int visible_above = 3;
        int visible_below = 3;
        
        // Draw devices
        for (int offset = -visible_above; offset <= visible_below; offset++) {
          int idx = id(device_select_index) + offset;
          
          // Skip invalid indices
          if (idx < 0 || idx >= total_items) continue;
          
          // Add extra spacing before Done button
          int y_offset = offset;
          if (idx == id(num_devices)) {
            y_offset += 1;  // Add extra spacing before Done
          } else if (id(device_select_index) == id(num_devices) && offset < 0) {
            y_offset -= 1;  // Adjust items above Done
          }
          
          // Calculate Y position for this item
          int y = active_y + (y_offset * item_spacing);
          
          // Skip if outside screen bounds
          if (y < 35 || y > 205) continue;
          
          // Calculate X position to follow circular contour (10 pixels from edge)
          int edge_offset = 12;
          float dy = y - center_y;
          float max_radius = 120.0;
          float usable_radius = max_radius - edge_offset;
          float dx = sqrt(usable_radius * usable_radius - dy * dy);
          int x = center_x - dx;  // Left side
          
          bool is_active = (idx == id(device_select_index));
          bool is_done = (idx == id(num_devices));
          
          // Check if device is selected
          bool is_checked = false;
          if (!is_done) {
            for (int j = 0; j < id(selected_devices).size(); j++) {
              if (id(selected_devices)[j] == idx) {
                is_checked = true;
                break;
              }
            }
          }
          
          // Draw checkbox and text
          if (is_done) {
            // Done button - 2x size checkbox, larger text
            Color checkbox_color = id(COLOR_GREEN);
            
            // Large checkbox icon (no background)
            it.printf(x + 20, y, id(font_icons), checkbox_color,
                     TextAlign::CENTER, "\U000F05E1");
            
            // "Done" text - larger
            it.printf(x + 55, y - 10, id(font_large), 
                     is_active ? id(COLOR_GREEN) : id(COLOR_LIGHT_GREY),
                     TextAlign::LEFT, "Done");
          } else {
            // Regular device item
            Color checkbox_color = is_checked ? id(COLOR_CYAN) : id(COLOR_DARK_GREY);
            const char* icon = is_checked ? "\U000F05E1" : "\U000F0130";
            
            // Checkbox icon (no background circle)
            it.printf(x + 10, y, id(font_icons), checkbox_color,
                     TextAlign::CENTER, icon);
            
            // Device name - aligned with checkbox
            Color text_color = is_active ? id(COLOR_WHITE) : id(COLOR_LIGHT_GREY);
            
            if (idx < id(num_devices)) {
              it.printf(x + 40, y - 10, is_active ? id(font_medium) : id(font_small), 
                       text_color, TextAlign::LEFT, 
                       "%s", id(device_names)[idx].c_str());
            }
          }
        }
        
        // Selection count at bottom right
        if (id(selected_devices).size() > 0) {
          it.printf(center_x + 60, 220, id(font_small), id(COLOR_CYAN), 
                   TextAlign::RIGHT, "%d selected", id(selected_devices).size());
        }
        
        // Scroll indicator dots on right side
        if (id(device_select_index) > 0) {
          it.filled_circle(center_x + 100, 60, 3, id(COLOR_WHITE));  // Up indicator
        }
        if (id(device_select_index) < total_items - 1) {
          it.filled_circle(center_x + 100, 180, 3, id(COLOR_WHITE));  // Down indicator
        }
      }
      // Color Wheel Menu - Modern Design
      else if (id(current_menu) == 2) {
        // Black background
        it.fill(id(COLOR_BLACK));
        
        int center_x = 120;
        int center_y = 120;
        
        // Title
        it.printf(center_x, 15, id(font_medium), id(COLOR_WHITE), 
                 TextAlign::CENTER, "Select Color");
        
        // Draw color wheel
        int outer_radius = 105;
        int inner_radius = 80;
        int num_segments = 60;
        
        for (int i = 0; i < num_segments; i++) {
          float angle_start = ((i * 360.0 / num_segments) + 90) * 3.14159 / 180.0;
          float angle_end = (((i + 1) * 360.0 / num_segments) + 90) * 3.14159 / 180.0;
          
          int hue = ((i * 360 / num_segments) + 180) % 360;
          
          uint8_t r, g, b;
          id(convert_hsv_to_rgb).execute(hue, 100, 100, r, g, b);
          Color segment_color = Color(r, g, b);
          
          for (int radius = inner_radius; radius < outer_radius; radius += 2) {
            int x1 = center_x + radius * cos(angle_start);
            int y1 = center_y + radius * sin(angle_start);
            int x2 = center_x + radius * cos(angle_end);
            int y2 = center_y + radius * sin(angle_end);
            it.line(x1, y1, x2, y2, segment_color);
          }
        }
        
        // Draw current color in center circle
        uint8_t r, g, b;
        id(convert_hsv_to_rgb).execute(id(color_hue), 100, 100, r, g, b);
        Color current_color = Color(r, g, b);
        it.filled_circle(center_x, center_y, 65, current_color);
        
        // Draw white border around center
        it.circle(center_x, center_y, 65, id(COLOR_WHITE));
        it.circle(center_x, center_y, 66, id(COLOR_WHITE));
        
        // Draw selection indicator pointing to current hue on wheel
        float selected_angle = (id(color_hue) - 90) * 3.14159 / 180.0;
        int indicator_x = center_x + 92 * cos(selected_angle);
        int indicator_y = center_y + 92 * sin(selected_angle);
        
        // White circle indicator with black outline
        it.filled_circle(indicator_x, indicator_y, 8, id(COLOR_WHITE));
        it.circle(indicator_x, indicator_y, 8, id(COLOR_BLACK));
        
        // Hue value in center (black or white depending on brightness)
        bool use_white_text = (id(color_hue) > 30 && id(color_hue) < 210);
        Color text_color = use_white_text ? id(COLOR_WHITE) : id(COLOR_BLACK);
        
        it.printf(center_x, center_y - 5, id(font_large), text_color, 
                 TextAlign::CENTER, "%d°", id(color_hue));
        
        // Color name below hue
        const char* color_name;
        int hue = id(color_hue);
        if (hue >= 345 || hue < 15) color_name = "Red";
        else if (hue < 45) color_name = "Orange";
        else if (hue < 75) color_name = "Yellow";
        else if (hue < 150) color_name = "Green";
        else if (hue < 210) color_name = "Cyan";
        else if (hue < 270) color_name = "Blue";
        else if (hue < 330) color_name = "Purple";
        else color_name = "Magenta";
        
        it.printf(center_x, center_y + 15, id(font_small), text_color, 
                 TextAlign::CENTER, "%s", color_name);
        
        // Instructions at bottom
        it.printf(center_x, 220, id(font_small), id(COLOR_LIGHT_GREY), 
                 TextAlign::CENTER, "Rotate dial or touch");
      }
      // Effect Menu
      else if (id(current_menu) == 3) {
        // ADJUSTED: Title moved down from y=25 to y=35
        it.printf(center_x, 35, id(font_large), id(COLOR_YELLOW), TextAlign::CENTER, "Select Effect");
        
        if (id(selected_device_index) >= id(num_devices) || id(effect_counts)[id(selected_device_index)] == 0) {
          it.printf(center_x, center_y, id(font_medium), id(COLOR_RED), TextAlign::CENTER, "No effects available");
          return;
        }
        
        int num_effects = id(effect_counts)[id(selected_device_index)];
        int visible = 5;
        int start_idx = max(0, id(menu_index) - 2);
        
        // ADJUSTED: Start list at y=70 instead of y=60
        for (int i = 0; i < visible && (start_idx + i) < num_effects; i++) {
          int idx = start_idx + i;
          int y = 70 + (i * 30);
          
          if (idx == id(menu_index)) {
            it.filled_rectangle(5, y - 3, 230, 26, id(COLOR_BLUE));
            it.printf(center_x, y + 10, id(font_small), id(COLOR_WHITE), TextAlign::CENTER, 
                     "%s", id(effect_lists)[id(selected_device_index)][idx].c_str());
          } else {
            it.printf(center_x, y + 10, id(font_small), id(COLOR_LIGHT_GREY), TextAlign::CENTER, 
                     "%s", id(effect_lists)[id(selected_device_index)][idx].c_str());
          }
        }
        
        it.printf(center_x, 210, id(font_small), id(COLOR_DARK_GREY), TextAlign::CENTER, "%d/%d", id(menu_index) + 1, num_effects);
      }
      // Brightness Menu - keep centered
      else if (id(current_menu) == 4) {
        it.printf(center_x, 35, id(font_large), id(COLOR_YELLOW), TextAlign::CENTER, "Brightness");
        
        int arc_radius = 90;
        float percent = id(brightness_value) / 255.0;
        int arc_degrees = percent * 270;
        
        for (int angle = -135; angle < 135; angle += 2) {
          float rad = angle * 3.14159 / 180.0;
          int x = center_x + arc_radius * cos(rad);
          int y = center_y + arc_radius * sin(rad);
          it.filled_circle(x, y, 3, id(COLOR_DARK_GREY));
        }
        
        for (int angle = -135; angle < -135 + arc_degrees; angle += 2) {
          float rad = angle * 3.14159 / 180.0;
          int x = center_x + arc_radius * cos(rad);
          int y = center_y + arc_radius * sin(rad);
          
          float position = (angle + 135) / 270.0;
          uint8_t r = 255;
          uint8_t g = 150 + (105 * position);
          uint8_t bl = 0;
          it.filled_circle(x, y, 4, Color(r, g, bl));
        }
        
        it.printf(center_x, center_y - 10, id(font_large), id(COLOR_WHITE), TextAlign::CENTER, "%d%%", (int)(percent * 100));
        it.printf(center_x, center_y + 20, id(font_small), id(COLOR_LIGHT_GREY), TextAlign::CENTER, "(%d/255)", id(brightness_value));
        
        it.printf(20, center_y, id(font_small), id(COLOR_GREY), TextAlign::LEFT, "0");
        it.printf(220, center_y, id(font_small), id(COLOR_GREY), TextAlign::RIGHT, "100");
      }
      // Group Selection Menu
      else if (id(current_menu) == 5) {
        it.printf(center_x, 35, id(font_large), id(COLOR_YELLOW), TextAlign::CENTER, "Select Group");
        
        int visible = 5;
        int start_idx = max(0, id(group_select_index) - 2);
        
        for (int i = 0; i < visible && (start_idx + i) < id(num_groups); i++) {
          int idx = start_idx + i;
          int y = 70 + (i * 30);
          
          bool is_selected = (idx == id(group_select_index));
          bool is_current = (idx == id(selected_group_index));
          
          if (is_selected) {
            it.filled_rectangle(5, y - 3, 230, 26, id(COLOR_BLUE));
          }
          
          if (is_current) {
            it.printf(15, y + 10, id(font_small), id(COLOR_GREEN), TextAlign::LEFT, ">");
          }
          
          it.printf(center_x, y + 10, id(font_small), 
                   is_selected ? id(COLOR_WHITE) : id(COLOR_LIGHT_GREY), 
                   TextAlign::CENTER, "%s", id(group_names)[idx].c_str());
        }
        
        it.printf(center_x, 210, id(font_small), id(COLOR_DARK_GREY), TextAlign::CENTER, "%d/%d", id(group_select_index) + 1, id(num_groups));
      }
      // Preset Selection Menu
      else if (id(current_menu) == 7) {
        it.printf(center_x, 35, id(font_large), id(COLOR_YELLOW), TextAlign::CENTER, "Presets");
        
        if (id(num_presets) == 0) {
          it.printf(center_x, center_y, id(font_medium), id(COLOR_RED), TextAlign::CENTER, "No presets saved");
          it.printf(center_x, center_y + 30, id(font_small), id(COLOR_WHITE), TextAlign::CENTER, "Create in future update");
          return;
        }
        
        int visible = 5;
        int start_idx = max(0, id(preset_select_index) - 2);
        
        for (int i = 0; i < visible && (start_idx + i) < id(num_presets); i++) {
          int idx = start_idx + i;
          int y = 70 + (i * 30);
          
          if (idx == id(preset_select_index)) {
            it.filled_rectangle(5, y - 3, 230, 26, id(COLOR_BLUE));
            it.printf(center_x, y + 10, id(font_small), id(COLOR_WHITE), TextAlign::CENTER, 
                     "%s", id(preset_names)[idx].c_str());
          } else {
            it.printf(center_x, y + 10, id(font_small), id(COLOR_LIGHT_GREY), TextAlign::CENTER, 
                     "%s", id(preset_names)[idx].c_str());
          }
        }
        
        it.printf(center_x, 210, id(font_small), id(COLOR_DARK_GREY), TextAlign::CENTER, "%d/%d", id(preset_select_index) + 1, id(num_presets));
      }
      else if (id(current_menu) == 8) {
        it.printf(center_x, 50, id(font_medium), id(COLOR_YELLOW), TextAlign::CENTER, "%d Devices Selected", id(selected_devices).size());
        it.printf(center_x, 75, id(font_small), id(COLOR_WHITE), TextAlign::CENTER, "What would you like to do?");
        
        // Option 0: Use once
        int y1 = 110;
        if (id(menu_index) == 0) {
          it.filled_rectangle(10, y1 - 5, 220, 30, id(COLOR_BLUE));
        }
        it.printf(center_x, y1 + 10, id(font_medium), 
                 id(menu_index) == 0 ? id(COLOR_WHITE) : id(COLOR_LIGHT_GREY), 
                 TextAlign::CENTER, "Use Once");
        
        // Option 1: Save as group
        int y2 = 150;
        if (id(menu_index) == 1) {
          it.filled_rectangle(10, y2 - 5, 220, 30, id(COLOR_BLUE));
        }
        it.printf(center_x, y2 + 10, id(font_medium), 
                 id(menu_index) == 1 ? id(COLOR_WHITE) : id(COLOR_LIGHT_GREY), 
                 TextAlign::CENTER, "Save as Group");
        
        it.printf(center_x, 210, id(font_small), id(COLOR_DARK_GREY), TextAlign::CENTER, "Rotate to choose");
      }

globals:
  # Existing globals
  - id: menu_index
    type: int
    initial_value: '0'
  - id: current_menu
    type: int
    initial_value: '0'
  - id: selected_device_index
    type: int
    initial_value: '0'
  - id: device_select_index
    type: int
    initial_value: '0'
  - id: color_hue
    type: int
    initial_value: '0'
  - id: brightness_value
    type: int
    initial_value: '128'
  
  - id: num_devices
    type: int
    initial_value: '0'
  - id: device_names
    type: std::vector<std::string>
    restore_value: no
  - id: device_entity_ids
    type: std::vector<std::string>
    restore_value: no
  - id: effect_lists
    type: std::vector<std::string>[20]
    restore_value: no
  - id: effect_counts
    type: int[20]
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'

  - id: selected_devices
    type: std::vector<int>
    restore_value: no
  - id: multi_select_mode
    type: bool
    initial_value: 'false'
  
  # NEW: Group management
  - id: num_groups
    type: int
    initial_value: '2'
    restore_value: no
  - id: group_names
    type: std::string[10]
    restore_value: no  # CHANGED - can't restore arrays of strings
  - id: group_devices
    type: std::vector<int>[10]
    restore_value: no  # CHANGED - can't restore arrays of vectors
  - id: selected_group_index
    type: int
    initial_value: '0'
    restore_value: yes
  - id: control_mode
    type: int
    initial_value: '0'
    restore_value: yes
  - id: group_select_index
    type: int
    initial_value: '0'
  
  # NEW: Presets
  - id: num_presets
    type: int
    initial_value: '0'
    restore_value: yes
  - id: preset_names
    type: std::string[10]
    initial_value: '{"", "", "", "", "", "", "", "", "", ""}'
    restore_value: no  # CHANGED - can't restore arrays of strings
  - id: preset_hues
    type: int[10]
    initial_value: '{0,0,0,0,0,0,0,0,0,0}'
    restore_value: yes  # Simple int array - OK to restore
  - id: preset_effects
    type: int[10]
    initial_value: '{0,0,0,0,0,0,0,0,0,0}'
    restore_value: yes  # Simple int array - OK to restore
  - id: preset_brightness
    type: int[10]
    initial_value: '{128,128,128,128,128,128,128,128,128,128}'
    restore_value: yes  # Simple int array - OK to restore
  - id: preset_select_index
    type: int
    initial_value: '0'
  
script:
  - id: convert_hsv_to_rgb  # Changed name
    parameters:
      h: int
      s: int
      v: int
      r: uint8_t&
      g: uint8_t&
      b: uint8_t&
    then:
      - lambda: |-
          float hf = h / 60.0;
          float sf = s / 100.0;
          float vf = v / 100.0;
          
          int i = (int)hf;
          float f = hf - i;
          float p = vf * (1.0 - sf);
          float q = vf * (1.0 - sf * f);
          float t = vf * (1.0 - sf * (1.0 - f));
          
          float rf, gf, bf;
          switch(i % 6) {
            case 0: rf = vf; gf = t; bf = p; break;
            case 1: rf = q; gf = vf; bf = p; break;
            case 2: rf = p; gf = vf; bf = t; break;
            case 3: rf = p; gf = q; bf = vf; break;
            case 4: rf = t; gf = p; bf = vf; break;
            case 5: rf = vf; gf = p; bf = q; break;
          }
          
          r = (uint8_t)(rf * 255);
          g = (uint8_t)(gf * 255);
          b = (uint8_t)(bf * 255);

  - id: toggle_power_action
    then:
      - if:
          condition:
            lambda: 'return id(control_mode) == 0 && id(selected_device_index) < id(num_devices);'
          then:
            - homeassistant.service:
                service: light.toggle
                data_template:
                  entity_id: !lambda 'return id(device_entity_ids)[id(selected_device_index)];'
      - if:
          condition:
            lambda: 'return id(control_mode) == 1;'
          then:
            - homeassistant.service:
                service: light.toggle
                data_template:
                  entity_id: !lambda |-
                    std::string entities = "";
                    for (int i = 0; i < id(group_devices)[id(selected_group_index)].size(); i++) {
                      int dev_idx = id(group_devices)[id(selected_group_index)][i];
                      if (dev_idx < id(num_devices)) {
                        if (i > 0) entities += ",";
                        entities += id(device_entity_ids)[dev_idx];
                      }
                    }
                    return entities;
